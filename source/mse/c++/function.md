---
title: 函数
---

{% note warn 小结%}

函数是有名字的计算单元，对程序(就算是小程序)的结构化至关重要。

函数的定义由`返回类型`、`函数名`、`形参表`(可能为空)以及`函数体`组成。

* 函数体是 调用函数时执行的语句块。
* 在调用函数时，传递给函数的实参必须与相应的形参类型兼容。
* 给函数传递实参遵循变量初始化的规则。非引用类型的形参以相应实参的副本初始化。对(非引用)形参的任何修改仅作用于局部副本，并不影响实参本身。
* 复制庞大而复杂的值有昂贵的开销。为了避免传递副本的开销，可将形参指定为引用类型。对引用形参的任何修改会直接影响实参本身。应将不需要修改相应实参的引用形参定义为 `const` 引用。
* 在 C++ 中，函数可以重载。只要函数中形参的个数或类型不同，则同一个函数名可用于定义不同的函数。编译器将根据函数调用时的实参确定调用哪一个函数。在重载函数集合中选择适合的函数的过程称为函数匹配。

C++ 提供了两种特殊的函数:`内联函数`和`成员函数`。
* 将函数指定为内联是建议编译器在调用点直接把函数代码展开。
* 内联函数避免了调用函数的代价。
* 成员函数则是身为类成员的函数。

自定义函数
```c++
//函数原型
//主体中调用函数
//函数定义
```
{% endnote %}



# 函数的定义

函数由函数名以及一组操作数类型唯一地表示。

* 函数的操作数，也即 `形参`，在一 对圆括号中声明，形参与形参之间以逗号分隔。
* 函数执行的运算在一个称为 `函数体` 的块语句中定义。
* 每一个函数都有一个相关联的 `返回类型`。

考虑下面的例子，这个函数用来求出两个 `int` 型数的最大公约数:

```c++
// return the greatest common divisor
     int gcd(int v1, int v2)
     {
         while (v2) {
            int temp = v2;
            v2 = v1 % v2;
            v1 = temp; }
        return v1; }
```

这里，定义了一个名为 gcd 的函数，该函数返回一个 `int` 型值，并带有两个 `int` 型形参。调用 `gcd` 函数时，必须提供两个 `int` 型值传递给函数，然后将得到一 个 `f` 型的返回值。


## 函数的调用

C++ 语言使用调用操作符(即一对圆括号)实现函数的调用。正如其他操作符一样，调用操作符需要操作数并产生一个结果。调用操作符的操作数是函数名和一 
组(有可能是空的)由逗号分隔的实参。函数调用的结果类型就是函数返回值的 类型，该运算的结果本身就是函数的返回值:

```c++
gcd(i, j) 
```

函数调用做了两件事情:
* 用对应的实参初始化函数的形参，并将控制权转移给被 调用函数。
* 主调函数的执行被挂起，被调函数开始执行。函数的运行以形参的(隐 式)定义和初始化开始。

也就是说，当我们调用 gcd 时，第一件事就是创建名 为 v1 和 v2 的 int 型变量，并将这两个变量初始化为调用 gcd 时传递的实参 值。在上例中，v1 的初值为 i，而 v2 则初始化为 j 的值。

{%note info 重要概念%}
函数名：记住命名规则，包含数字、字符串和`_`,不可以以数字开头
形参：为函数提供了已命名的局部存储空间。
函数体:是一个作用域.
返回值：返回类型可以是内置类型(如 int 或者 double)、类类型或复合类型(如 int& 或 string*)，还可以是 void 类型，表示该函数不返回任何值。

局部变量: 在函数体内定义的变量只在该函数中才可以访问。
形参和实参：
* 形参：为函数提供了已命名的局部存储空间。（定义时使用）
* 实参：则是一个表达式。它可以是变量或字面值常量，甚至是包含一个或几个操作符的表达式。（调用时使用）
{% endnote %}

## 函数返回类型

函数的返回类型可以是内置类型(如 `int` 或者 `double`)、类类型或复合类型(如 `int&` 或 `string*`)，还可以是 `void` 类型，表示该函数不返回任何值。

函数必须指定返回类型！

在定义或声明函数时，没有显式指定返回类型是不合法的。


## 函数形参表

函数形参表可以为空，但不能省略。没有任何形参的函数可以用空形参表或含有
单个关键字 void 的形参表来表示。

下面关于 process 的声明是等价的:

```c++
void process() { /* ... */ } // implicit void parameter list 
void process(void){ /* ... */ } // equivalent declaration
```

形参表由一系列用`逗号分隔`的`参数类型`和`(可选的)参数名`组成。如果两个参数 
具有相同的类型，则其类型必须重复声明:

```c++
     int manip(int v1, v2) { /* ... */ }      // error
     int manip(int v1, int v2) { /* ... */ }  // ok
```

参数表中不能出现同名的参数。类似地，局部于函数的变量也不能使用与函数的 
任意参数相同的名字。

参数名是可选的，但在函数定义中，通常所有参数都要命名。参数必须在命名后才能使用。

参数类型c++会自动检查合法性。


# 参数传递

每次调用函数时，都会重新创建该函数所有的形参，此时所传递的实参将会初始化对应的形参。

## 非引用形参

普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初 
始化形参时，函数并没有访问调用所传递的实参本身，因此不会修改实参的值。 

下面再次观察 `gcd` 这个函数的定义:

```c++
     // return the greatest common divisor
     int gcd(int v1, int v2)
     {
         while (v2) {
             int temp = v2;
             v2 = v1 % v2;
             v1 = temp; }
         return v1; }

```

`while` 循环体虽然修改了 `v1` 与 `v2` 的值，但这些变化仅限于局部参数，而 
对调用 `gcd` 函数使用的实参没有任何影响。于是，如果有函数调用
`gcd(i, j)`
则 `i` 与 `j` 的值不受 `gcd` 内执行的赋值操作的影响。

    非引用形参表示对应实参的局部副本。对这类形参的修改仅仅
    改变了局部副本的值。一旦函数执行结束，这些局部变量的值
    也就没有了。


## 指针形参


# return 语句

# 函数声明

# 局部对象

## 自动对象

默认情况下，局部变量的生命期局限于所在函数的每次执行期间。只有当定 
义它的函数被调用时才存在的对象称为自动对象。自动对象在每次调用函数时创 
建和撤销。

局部变量所对应的自动对象在函数控制经过变量定义语句时创建。如果在定 
义时提供了初始化式，那么每次创建对象时，对象都会被赋予指定的初值。对于 
未初始化的内置类型局部变量，其初值不确定。当函数调用结束时，自动对象就 
会撤销。

形参也是自动对象。形参所占用的存储空间在调用函数时创建，而在函数结 
束时撤销。

自动对象，包括形参，都在定义它们的块语句结束时撤销。形参在函数块中 
定义，因此当函数的执行结束时撤销。当函数结束时，会释放它的局部存储空间。 
在函数结束后，自动对象和形参的值都不能再访问了。

## 静态局部对象

一个变量如果位于函数的作用域内，但生命期跨越了这个函数的多次调用，
这种变量往往很有用。则应该将这样的对象定义为 **static(静态的)**。

static 局部对象确保不迟于在程序执行流程第一次经过该对象的定义语句 
时进行初始化。这种对象一旦被创建，在程序结束前都不会撤销。当定义静态局 
部对象的函数结束时，静态局部对象不会撤销。在该函数被多次调用的过程中， 
静态局部对象会持续存在并保持它的值。考虑下面的小例子，这个函数计算了自 
己被调用的次数:

```c++
size_t count_calls()
     {
          static size_t ctr = 0; // value will persist across calls
          return ++ctr;
     }
int main() 
    {
         for (size_t i = 0; i != 10; ++i)
             cout << count_calls() << endl;
        return 0; 
    }

```

这个程序会依次输出 1 到 10(包含 10)的整数。

在第一次调用函数 `count_calls` 之前，`ctr` 就已创建并赋予初值 `0`。每次 
函数调用都使加 `1`，并且返回其当前值。在执行函数 `count_calls` 时，变量 `ctr` 
就已经存在并且保留上次调用该函数时的值。因此，第二次调用时，ctr 
的值为 `1`，第三次为 `2`，依此类推。

# 内联函数

# 类的成员函数

# 重载函数

# 指向函数的指针

## 自定义函数

```c++
int sum(int, int); //函数原型
int main()
{
    // 函数调用
    int result = sum(5, 3);
}
// 函数定义
int sum(int num1, int num2)
{
    // 函数实现的代码
}
```



# 术语

| 术语 | 解释 |
| ---- | ---- |
|ambiguous call(有二义性的调用)| 一种编译错误，当调用重载函数，找不到唯一的最佳匹配时产生。|
|arguments(实参)|调用函数时提供的值。这些值用于初始化相应的形参，其方式类似于初始 化同类型变量的方法。|
|automatic objects(自动对象)|局部于函数的对象。自动对象会在每一次函数调用时重新创建和初始化， 并在定义它的函数块结束时撤销。一旦函数执行完毕，这些对象就不再存 在了。|
|best match(最佳匹配) |在重载函数集合里找到的与给定调用的实参达到最佳匹配的唯一函数。|
|call operator(调用操作符)|使函数执行的操作符。该操作符是一对圆括号，并且有两个操作数:被调 用函数的名字，以及由逗号分隔的(也可能为空)形参表。|
|candidate functions(候选函数)|在解析函数调用时考虑的函数集合。候选函数包括了所有在该调用发生的 作用域中声明的、具有该调用所使用的名字的函数。|
|const member function(常量成员函数)|类的成员函数，并可以由该类类型的常量对象调用。常量成员函数不能修 改所操纵的对象的数据成员。|
|constructor(构造函数)|与所属类同名的类成员函数。构造函数说明如何初始化本类的对象。构造 函数没有返回类型，而且可以重载。|
|constructor initializer list(构造函数初始化列表)|在构造函数中用于为数据成员指定初值的表。初始化列表出现在构造函数 的定义中，位于构造函数体与形参表之间。该表由冒号和冒号后面的一组 用逗号分隔的成员名组成，每一个成员名后面跟着用圆括号括起来的该成 员的初值。|
|default constructor(默认构造函数)|在没有显式提供初始化式时调用的构造函数。如果类中没有定义任何构造 函数，编译器会自动为这个类合成默认构造函数。|
|function(函数)| 可调用的计算单元。|
|function body(函数体) |定义函数动作的语句块。|
|function matching(函数匹配)|确定重载函数调用的编译器过程。调用时使用的实参将与每个重载函数的 形参表作比较。|
|function prototype(函数原型)|函数声明的同义词。包括了函数的名字、返回类型和形参类型。调用函数 时，必须在调用点之前声明函数原型。|
|inline function(内联函数)|如果可能的话，将在调用点展开的函数。内联函数直接以函数代码替代了 函数调用点展开的函数。内联函数直接以函数代码替代了函数调用语句， 从而避免了一般函数调用的开销。|
|local static objects(局部静态对象)|在函数第一次调用前就已经创建和初始化的局部对象，其值在函数的调用之间保持有效。|
|local variables(局部变量) |在函数内定义的变量，仅能在函数体内访问。|
|object lifetime(对象生命期)|每个对象皆有与之关联的生命期。在块中定义的对象从定义时开始存在， 直到它的定义所在的语句块结束为止。静态局部对象和函数外定义的全局 变量则在程序开始执行时创建，当 main 函数结束时撤销。动态创建的对 象由 new 表达式创建，从此开始存在，直到由相应的 delete 表达式释 放所占据的内存空间为止。|
|overload resolution(重载确定) |函数匹配的同义词。|
|overloaded function(重载函数)|和至少一个其他函数同名的函数。重载函数必须在形参的个数或类型上有 所不同。|
|parameters(形参) |函数的局部变量，其初值由函数调用提供。|
|recursive function(递归函数)| 直接或间接调用自己的函数。|
|return type(返回类型) |函数返回值的类型。|
|synthesized default constructor(合成默认构造函数)|如果类没有定义任何构造函数，则编译器会为这个类创建(合成)一个默 认构造函数。该函数以默认的方式初始化类中的所有数据成员。|
|temporary object(临时对象)|在求解表达式的过程中由编译器自动创建的没有名字的对象。“临时对 象”这个术语通常简称为“临时”。临时对象一直存在直到最大表达式结束为止，最大表达式指的是包含创建该临时对象的表达式的最大范围内的 表达式。|
|this pointer(this 指针)|成员函数的隐式形参。this 指针指向调用该函数的对象，是指向类类型 的指针。在 const 成员函数中，该指针也指向 const 对象。|
|viable functions(可行函数)|重载函数中可与指定的函数调用匹配的子集。可行函数的形参个数必须与 该函数调用的实参个数相同，而且每个实参类型都可潜在地转换为相应形参的类型。|





# 课堂实践

## 实践1

要求：解释形参、局部变量和静态局部变量的差别。并给出一个有效使用了这三种变量的程序例子。

## 实践2
